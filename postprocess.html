<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CriticalSnake Tests</title>
  <style>
    body {
      background: #333;
    }
    pre {
      color: #fff;
    }
    div#osm-map {
      position: absolute;
      left: 0px;
      top: 0px;
      width: 100%;
      height: 100%;
    }
    div.filtered {
      -webkit-filter: grayscale(50%);
      filter: grayscale(50%);
    }
  </style>
</head>
<body>
  <div id="osm-map"></div>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js"></script>
  <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>

  <script src="critical-snake/common.js"></script>
  <script src="critical-snake/marker.js"></script>
  <script src="critical-snake/bikemap.js"></script>
  <script src="critical-snake/postprocess.js"></script>
  <script src="critical-snake/utils.js"></script>

  <script>
    let fetchTimer = null;
    let settings = {
      city: "Berlin",
      bounds: null, // overwrites city, e.g. "[[52.40,13.23],[52.61,13.56]]"
      dataset: null,
      fps: "10",
      show_stats: "1",
      show_controls: "1",
      show_zoom: "1",
      colors: "0",
      group_dist: "0.0025",
      group_size: "16"
    };

    settings = { ...settings, ...parseUrlParams(window.location.href) };

    const replayCoordFilter = settings.bounds ? createBoundsCoordFilter(settings.bounds)
                                              : createCityCoordFilter(settings.city);

    const baseLayer = L.tileLayer(
      'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png',
      { attribution:
          '<a href="{0}">{1}</a> | &copy; <a href="{2}">{3}</a>'.format(
            'https://foundation.wikimedia.org/wiki/Maps_Terms_of_Use',
            'Wikimedia maps', 'http://osm.org/copyright', 'OpenStreetMap'
          )
      }
    );

    let bikeMap = createReplayMap(L, baseLayer, {
      showStats: toBool(settings.show_stats),
      showControls: toBool(settings.show_controls),
      showZoom: toBool(settings.show_zoom)
    });

    let markers = createMarkers(L, toBool(settings["colors"]));
    bikeMap.createMarker = (loc) => {
      return L.marker(loc.coord, { icon: markers.bySnakeIdx(loc.snake) });
    };

    let playbackFrameIdx = 0;
    let playbackDataset = null;
    bikeMap.onPlaybackClicked = (playbackButton) => {
      if (isRunning(playbackButton)) {
        pause(playbackButton);
      } else {
        resume(playbackButton);
      }
    };

    bikeMap.onSliderMoved = (sliderElement) => {
      playbackFrameIdx = sliderElement.value;
      refreshView();
    };

    bikeMap.onMapZoomed = (bikeMap) => {
      const px = Math.max(1, bikeMap.getZoom() - 10) * 6;
      markers.updateSize(px);
    };

    // ----------------------------------------------------

    $("#browse").change(function () {
      $("#browse").hide();
      $("#progress").text("Loading..");
      $("#progress").show();

      if (this.files.length == 0)
        return;

      if (this.files.length > 1)
        console.warn("Can only playback one file at a time:", this.files[0].name);

      const reader = new FileReader();
      $(reader).on('load', (event) => {
        let rawJSONs = [];
        const lines = event.target.result.split("\n");
        try {
          for (const line of lines) {
            rawJSONs.push(JSON.parse(line));
          }
        }
        catch (ex) {
          if (lines.length == rawJSONs.length + 1) {
            console.assert(lines[lines.length - 1] == "");
            console.log("Received", rawJSONs.length, "frames");
          }
          else {
            console.error("JSON parsing failed on frame", rawJSONs.length,
                          "Can only playback previous ones.");
          }
        }

        loadIt(rawJSONs);
      });

      reader.readAsText(this.files[0]);
    });

    function loadIt(rawJSONs) {
      playbackFrameIdx = 0;
      playbackDataset = postprocess(rawJSONs, {
        coordFilter: replayCoordFilter,
        groupDistanceMax: parseFloat(settings.group_dist),
        groupSizeMin: parseInt(settings.group_size)
      });

      (new L.marker(playbackDataset.origin, { icon: markers.origin })).addTo(bikeMap);

      const snakeBounds = new L.latLngBounds([
        playbackDataset.snakeBounds.min,
        playbackDataset.snakeBounds.max
      ]);

      const zoomLevel = 16;
      bikeMap.flyTo(playbackDataset.origin, zoomLevel, { animate: true });

      $("#progress").hide();
      $("#playback").show();
      let stats = $("#stats");
      const stamp = playbackDataset.frames[0].timestamp;
      stats.text("ðŸ“… {0} ðŸ•— {1}".format(toDateUTC(stamp), toTimeUTC(stamp)));
      stats.css("display", "block");

      let slider = $("#history");
      slider.attr({
        "min": 0,
        "max": playbackDataset.frames.length - 1,
        "value": 0
      });
      slider.show();
    }

    // ----------------------------------------------------

    let playbackBeginAction = () => {};
    let playbackEndAction = () => {};
    function refreshView() {
      switch (playbackFrameIdx) {
        case 0:
          playbackBeginAction();
          break;
        case playbackDataset.frames.length:
          playbackEndAction();
          return;
      }

      const hist = $("#history");
      if (hist.hasOwnProperty("0"))
        hist[0].value = playbackFrameIdx;

      let frame = playbackDataset.frames[playbackFrameIdx];
      let trackedBikes = bikeMap.update(frame.locations);

      $("#stats").text("ðŸ“… {0} ðŸ•— {1} ðŸ“ðŸš² {2}".format(
        toDateUTC(frame.timestamp), toTimeUTC(frame.timestamp), trackedBikes));

      playbackFrameIdx += 1;
    }

    // ----------------------------------------------------

    function resume(playbackButton) {
      if (playbackButton)
        playbackButton.value = "||";

      fetchTimer = setInterval(refreshView, 1000 / parseInt(settings.fps));
      playbackBeginAction = () => {
        const snakeBounds = new L.latLngBounds([
          playbackDataset.snakeBounds.min,
          playbackDataset.snakeBounds.max
        ]);

        bikeMap.fitBounds(snakeBounds, { animate: true });
      };
      playbackEndAction = () => {
        clearTimeout(fetchTimer);
        $("#playback").attr("value", "â–¶");
        playbackFrameIdx = 0;
      };
    }

    function pause(playbackButton) {
      playbackButton.value = "â–¶";
      clearTimeout(fetchTimer);
    }

    function isRunning(playbackButton) {
      return playbackButton.value != "â–¶";
    }

    function fetchDataset(datasetUrl) {
      return new Promise(function(resolve, reject) {
        $.ajax({ url: datasetUrl })
          .done(dataStr => {
            if (dataStr) {
              const re = new RegExp(/\n/, 'g');
              dataStr = dataStr.trim().replace(re, ",\n");
              const jsonData = JSON.parse("[" + dataStr + "]");
              resolve(jsonData);
            }
            else {
              reject("Empty response from " + url);
            }
          })
        .fail(() => {
          reject("Error querying data from " + url);
        });
      });
    }

    $(() => {
      if (settings.dataset) {
        fetchDataset(settings.dataset).then(locations => {
          console.log("Replaying " + settings.dataset);
          loadIt(locations);
          resume(null);
        });
      }
    });
  </script>
</body>
</html>
