<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CriticalSnake</title>
  <style>
    body {
      background: #333;
    }
    pre {
      color: #fff;
    }
    div#osm-map {
      position: absolute;
      left: 0px;
      top: 0px;
      width: 100%;
      height: 100%;
    }
    div.filtered {
      -webkit-filter: grayscale(50%);
      filter: grayscale(50%);
    }
  </style>
</head>
<body>
  <div id="osm-map"></div>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js"></script>
  <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>

  <script src="critical-snake/common.js"></script>
  <script src="critical-snake/marker.js"></script>
  <script src="critical-snake/bikemap.js"></script>
  <script src="critical-snake/postprocess.js"></script>
  <script src="critical-snake/utils.js"></script>

  <script>
    let settings = {
      city: "Berlin",
      bounds: null, // overwrites city, e.g. "[[52.40,13.23],[52.61,13.56]]"
      dataset: null,
      fps: "10",
      show_stats: "1",
      show_controls: "1",
      show_zoom: "1",
      colors: "0",
      group_dist: "0.0025",
      group_size: "16"
    };

    let playback = {
      running: false,
      dataset: null,
      frameIdx: 0,
      fetchTimer: null
    };

    settings = { ...settings, ...parseUrlParams(window.location.href) };

    const replayCoordFilter = settings.bounds
            ? createBoundsCoordFilter(JSON.parse(settings.bounds))
            : createCityCoordFilter(settings.city);

    const baseLayer = L.tileLayer(
      'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png',
      { attribution:
          '<a href="{0}">{1}</a> | &copy; <a href="{2}">{3}</a>'.format(
            'https://foundation.wikimedia.org/wiki/Maps_Terms_of_Use',
            'Wikimedia maps', 'http://osm.org/copyright', 'OpenStreetMap'
          )
      }
    );

    let bikeMap = createReplayMap(L, $, baseLayer, {
      showStats: toBool(settings.show_stats),
      showControls: toBool(settings.show_controls),
      showZoom: toBool(settings.show_zoom)
    });

    let markers = createMarkers(L, toBool(settings["colors"]));
    bikeMap.createMarker = (loc) => {
      return L.marker(loc.coord, { icon: markers.bySnakeIdx(loc.snake) });
    };

    bikeMap.onPlaybackClicked = (btn) => {
      if (playback.running) {
        pause();
      } else {
        resume();
      }
    };

    bikeMap.onSliderMoved = (sliderElement) => {
      playback.frameIdx = parseInt(sliderElement.value);
      refreshView();
    };

    bikeMap.onMapZoomed = (bikeMap) => {
      const px = Math.max(1, bikeMap.getZoom() - 10) * 6;
      markers.updateSize(px);
    };

    bikeMap.onBrowseClicked = (ctrl) => {
      bikeMap.setLoadingInProgress();

      if (ctrl.files.length == 0)
        return;

      if (ctrl.files.length > 1)
        console.warn("Can only playback one file at a time:", ctrl.files[0].name);

      const reader = new FileReader();
      $(reader).on('load', (event) => {
        let rawJSONs = [];
        const lines = event.target.result.split("\n");
        try {
          for (const line of lines) {
            rawJSONs.push(JSON.parse(line));
          }
        }
        catch (ex) {
          if (lines.length == rawJSONs.length + 1) {
            console.assert(lines[lines.length - 1] == "");
            console.log("Received", rawJSONs.length, "frames");
          }
          else {
            console.error("JSON parsing failed on frame", rawJSONs.length,
                          "Can only playback previous ones.");
          }
        }

        load(rawJSONs);

        const zoomLevel = 16;
        bikeMap.flyTo(playback.dataset.origin, zoomLevel, { animate: true });
      });

      reader.readAsText(ctrl.files[0]);
    };

    function load(rawJSONs) {
      playback.frameIdx = 0;
      playback.dataset = postprocess(rawJSONs, {
        coordFilter: replayCoordFilter,
        groupDistanceMax: parseFloat(settings.group_dist),
        groupSizeMin: parseInt(settings.group_size)
      });

      bikeMap.addLayer(new L.marker(playback.dataset.origin, {
        icon: markers.origin
      }));

      const stamp = playback.dataset.frames[0].timestamp;
      const longDateStr = toDateUTCMonthName(stamp);
      const cityStr = (!settings.bounds) ? settings.city : '';
      document.title = "CriticalSnake: {0} {1}".format(cityStr, longDateStr);

      bikeMap.setLoadingDone();
      bikeMap.updateStats(playback.dataset.frames[0].timestamp);
      bikeMap.resetPlaybackPos(playback.dataset.frames.length - 1);
    }

    // ----------------------------------------------------

    function refreshView() {
      if (playback.frameIdx == 0) {
        playbackBeginAction();
      }

      let frame = playback.dataset.frames[playback.frameIdx];
      let trackedBikes = bikeMap.update(frame.locations);

      bikeMap.updatePlaybackPos(playback.frameIdx);
      bikeMap.updateStats(frame.timestamp, trackedBikes);

      if (playback.frameIdx == playback.dataset.frames.length - 1) {
        playbackEndAction();
      }
    }

    function playbackBeginAction() {
//      const snakeBounds = new L.latLngBounds([
//        playback.dataset.snakeBounds.min,
//        playback.dataset.snakeBounds.max
//      ]);
//
//      bikeMap.fitBounds(snakeBounds, { animate: true });
    }

    function playbackEndAction() {
      playback.frameIdx = 0;
      if (playback.running) {
        pause();
      }
    };

    // ----------------------------------------------------

    function resume() {
      playback.running = true;
      bikeMap.setPlaybackState(playback.running);

      const ms = 1000 / parseInt(settings.fps);
      playback.fetchTimer = setInterval(() => {
        refreshView();
        playback.frameIdx += 1;
      }, ms);

      const snakeBounds = new L.latLngBounds([
        playback.dataset.snakeBounds.min,
        playback.dataset.snakeBounds.max
      ]);

      bikeMap.fitBounds(snakeBounds, { animate: true });
    }

    function pause() {
      playback.running = false;
      bikeMap.setPlaybackState(playback.running);
      clearTimeout(playback.fetchTimer);
    }

    function fetchDataset(datasetUrl) {
      return new Promise(function(resolve, reject) {
        $.ajax({ url: datasetUrl })
          .done(dataStr => {
            if (dataStr) {
              const re = new RegExp(/\n/, 'g');
              dataStr = dataStr.trim().replace(re, ",\n");
              const jsonData = JSON.parse("[" + dataStr + "]");
              resolve(jsonData);
            }
            else {
              reject("Empty response from " + url);
            }
          })
        .fail(() => {
          reject("Error querying data from " + url);
        });
      });
    }

    $(() => {
      if (settings.dataset) {
        fetchDataset(settings.dataset).then(locations => {
          bikeMap.setLoadingInProgress();
          console.log("Replaying " + settings.dataset);
          load(locations);
          resume();
        });
      }
    });
  </script>
</body>
</html>
