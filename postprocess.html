<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CriticalSnake Tests</title>
  <style>
    body {
      background: #333;
    }
    pre {
      color: #fff;
    }
    div#osm-map {
      position: absolute;
      left: 0px;
      top: 0px;
      width: 100%;
      height: 100%;
    }
    div.filtered {
      -webkit-filter: grayscale(50%);
      filter: grayscale(50%);
    }
  </style>
</head>
<body>
  <div id="osm-map"></div>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js"></script>
  <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
  <!-- <script src="http://maps.stamen.com/js/tile.stamen.js?v1.3.0"></script> -->

  <script src="critical-snake/common.js"></script>
  <script src="critical-snake/marker.js"></script>
  <script src="critical-snake/bikemap.js"></script>
  <script src="critical-snake/postprocess.js"></script>
  <script src="critical-snake/utils.js"></script>

  <script>
    let fetchTimer = null;
    let settings = {
      city: "Berlin",
      bounds: null, // overwrites city, e.g. "[[52.40,13.23],[52.61,13.56]]"
      location_source: "https://api.criticalmaps.net/postv2",
      fps: "10",
      show_stats: "1",
      show_controls: "1",
      show_zoom: "1",
      colors: "0"
    };

    settings = { ...settings, ...parseUrlParams(window.location.href) };
    const showMarkerColors = toBool(settings["colors"]);

    const baseLayer = L.tileLayer(
      'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png',
      { attribution:
          '<a href="{0}">{1}</a> | &copy; <a href="{2}">{3}</a>'.format(
            'https://foundation.wikimedia.org/wiki/Maps_Terms_of_Use',
            'Wikimedia maps', 'http://osm.org/copyright', 'OpenStreetMap'
          )
      }
    );

//    let layerUrl = "http://c.tile.stamen.com/watercolor/${z}/${x}/${y}.jpg";
//    const baseLayer = new L.StamenTileLayer("watercolor", {
//      detectRetina: true
//    });

    let bikeMap = createBikeMap(L, baseLayer, {
      showStats: toBool(settings.show_stats),
      showControls: toBool(settings.show_controls),
      showZoom: toBool(settings.show_zoom)
    });

    let markers = createMarkers(L, showMarkerColors);
    bikeMap.createMarker = (loc) => {
      return L.marker(loc.coord, { icon: markers.bySnakeIdx(loc.snake) });
    };

    let playbackFrameIdx = 0;
    let playbackDataset = null;
    bikeMap.onPlaybackClicked = (playbackButton) => {
      if (isRunning(playbackButton)) {
        pause(playbackButton);
      } else {
        resume(playbackButton);
      }
    };

    bikeMap.onSliderMoved = (sliderElement) => {
      playbackFrameIdx = sliderElement.value;
      refreshView();
    };

    bikeMap.onMapZoomed = (bikeMap) => {
      const px = Math.max(1, bikeMap.getZoom() - 10) * 6;
      markers.updateSize(px);
    };

    // ----------------------------------------------------

    $("#browse").change(function () {
      $("#browse").hide();
      $("#progress").text("Loading..");
      $("#progress").show();

      if (this.files.length == 0)
        return;

      if (this.files.length > 1)
        console.warn("Can only playback one file at a time:", this.files[0].name);

      const reader = new FileReader();
      $(reader).on('load', (event) => {
        let rawJSONs = [];
        const lines = event.target.result.split("\n");
        try {
          for (const line of lines) {
            rawJSONs.push(JSON.parse(line));
          }
        }
        catch (ex) {
          if (lines.length == rawJSONs.length + 1) {
            console.assert(lines[lines.length - 1] == "");
            console.log("Received", rawJSONs.length, "frames");
          }
          else {
            console.error("JSON parsing failed on frame", rawJSONs.length,
                          "Can only playback previous ones.");
          }
        }

        let locationFilter = null;
        if (settings.bounds) {
          const bounds = L.latLngBounds(JSON.parse(settings.bounds));
          locationFilter = (coord) => bounds.contains(coord);
        }
        else {
          locationFilter = getCoordFilter(settings.city)
        }
        playbackDataset = postprocess(rawJSONs, locationFilter);
        playbackFrameIdx = 0;

        (new L.marker(playbackDataset.origin, { icon: markers.origin })).addTo(bikeMap);
        //(new L.marker(L.latLng(...playbackDataset.snakeBounds.max), { icon: markers[2] })).addTo(bikeMap);

        const snakeBounds = new L.latLngBounds([
          playbackDataset.snakeBounds.min,
          playbackDataset.snakeBounds.max
        ]);

        const zoomLevel = 16;
        bikeMap.flyTo(playbackDataset.origin, zoomLevel, { animate: true });

        $("#progress").hide();
        $("#playback").show();
        let stats = $("#stats");
        const stamp = playbackDataset.frames[0].timestamp;
        stats.text("📅 {0} 🕗 {1}".format(toDateUTC(stamp), toTimeUTC(stamp)));
        stats.css("display", "block");

        let slider = $("#history");
        slider.attr({
          "min": 0,
          "max": playbackDataset.frames.length - 1,
          "value": 0
        });
        slider.show();
      });

      reader.readAsText(this.files[0]);
    });

    // ----------------------------------------------------

    let playbackBeginAction = () => {};
    let playbackEndAction = () => {};
    function refreshView() {
      switch (playbackFrameIdx) {
        case 0:
          playbackBeginAction();
          break;
        case playbackDataset.frames.length:
          playbackEndAction();
          return;
      }

      $("#history")[0].value = playbackFrameIdx;

      let frame = playbackDataset.frames[playbackFrameIdx];
      let trackedBikes = bikeMap.update(frame.locations);

      $("#stats").text("📅 {0} 🕗 {1} 📍🚲 {2}".format(
        toDateUTC(frame.timestamp), toTimeUTC(frame.timestamp), trackedBikes));

      playbackFrameIdx += 1;
    }

    // ----------------------------------------------------

    function resume(playbackButton) {
      playbackButton.value = "||";
      fetchTimer = setInterval(refreshView, 1000 / parseInt(settings.fps));
      playbackBeginAction = () => {
        const snakeBounds = new L.latLngBounds([
          playbackDataset.snakeBounds.min,
          playbackDataset.snakeBounds.max
        ]);

        bikeMap.fitBounds(snakeBounds, { animate: true });
      };
      playbackEndAction = () => {
        clearTimeout(fetchTimer);
        $("#playback").attr("value", "▶");
        playbackFrameIdx = 0;
      };
    }

    function pause(playbackButton) {
      playbackButton.value = "▶";
      clearTimeout(fetchTimer);
    }

    function isRunning(playbackButton) {
      return playbackButton.value != "▶";
    }
  </script>
</body>
</html>
